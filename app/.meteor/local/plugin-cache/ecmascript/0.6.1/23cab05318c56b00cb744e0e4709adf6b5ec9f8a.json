{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/lib/helpers/helperFunctions.js","filenameRelative":"/imports/lib/helpers/helperFunctions.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/lib/helpers/helperFunctions.js.map","sourceFileName":"/imports/lib/helpers/helperFunctions.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"helperFunctions"},"ignored":false,"code":"/**\nHelper functions\n\n@module Helpers\n**/\n\n/**\nThe Helpers class containing helper functions\n\n@class Helpers\n@constructor\n**/\n\nHelpers = {};\n\n/**\nReruns functions reactively, based on an interval. Use it like so:\n\n    Helpers.rerun['10s'].tick();\n\n@method (rerun)\n**/\n\nHelpers.rerun = {\n    '10s': new ReactiveTimer(10)\n};\n\n/**\nClear localStorage\n\n@method (getLocalStorageSize)\n**/\n\nHelpers.getLocalStorageSize = function () {\n\n    var size = 0;\n    if (localStorage) {\n        _.each(Object.keys(localStorage), function (key) {\n            size += localStorage[key].length * 2 / 1024 / 1024;\n        });\n    }\n\n    return size;\n};\n\n/**\nReactive wrapper for the moment package.\n\n@method (moment)\n@param {String} time    a date object passed to moment function.\n@return {Object} the moment js package\n**/\n\nHelpers.moment = function (time) {\n\n    // react to language changes as well\n    TAPi18n.getLanguage();\n\n    if (_.isFinite(time) && moment.unix(time).isValid()) return moment.unix(time);else return moment(time);\n};\n\n/**\nFormats a timestamp to any format given.\n\n    Helpers.formatTime(myTime, \"YYYY-MM-DD\")\n\n@method (formatTime)\n@param {String} time         The timstamp, can be string or unix format\n@param {String} format       the format string, can also be \"iso\", to format to ISO string, or \"fromnow\"\n@return {String} The formated time\n**/\n\nHelpers.formatTime = function (time, format) {\n    //parameters\n\n    // make sure not existing values are not Spacebars.kw\n    if (format instanceof Spacebars.kw) format = null;\n\n    if (time) {\n\n        if (_.isString(format) && !_.isEmpty(format)) {\n\n            if (format.toLowerCase() === 'iso') time = Helpers.moment(time).toISOString();else if (format.toLowerCase() === 'fromnow') {\n                // make reactive updating\n                Helpers.rerun['10s'].tick();\n                time = Helpers.moment(time).fromNow();\n            } else time = Helpers.moment(time).format(format);\n        }\n\n        return time;\n    } else return '';\n};\n\n/**\nRefreshes the status of the currently searched name\n**/\nHelpers.refreshStatus = function () {\n    function refreshStatus() {\n        var name = Session.get('searched');\n        Session.set('searched', '');\n        Session.set('searched', name);\n    }\n\n    return refreshStatus;\n}();\n\n/**\nWaits for a tx to get mined into a block and\nreturns if the tx was successful or not.\n**/\nHelpers.checkTxSuccess = function () {\n    function checkTxSuccess(txid, callback) {\n        function whenMined(txid, cb) {\n            function check() {\n                web3.eth.getTransaction(txid, function (err, tx) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    if (tx.blockNumber) {\n                        cb(null, tx);\n                    } else {\n                        setTimeout(check, 500);\n                    }\n                });\n            }\n            check();\n        }\n\n        whenMined(txid, function (err, tx) {\n            if (err) {\n                return callback(err);\n            }\n            web3.eth.getTransactionReceipt(txid, function (err, receipt) {\n                console.log('Gas: ' + tx.gas + ' Gas used: ' + receipt.gasUsed);\n                if (receipt.gasUsed < tx.gas) {\n                    callback(null, true);\n                } else {\n                    callback(null, false);\n                }\n            });\n        });\n    }\n\n    return checkTxSuccess;\n}();\n\nmodule.export(\"default\",exports.default=(Helpers));","ast":null,"map":{"version":3,"sources":["/imports/lib/helpers/helperFunctions.js"],"names":["Helpers","rerun","ReactiveTimer","getLocalStorageSize","size","localStorage","_","each","Object","keys","key","length","moment","time","TAPi18n","getLanguage","isFinite","unix","isValid","formatTime","format","Spacebars","kw","isString","isEmpty","toLowerCase","toISOString","tick","fromNow","refreshStatus","name","Session","get","set","checkTxSuccess","txid","callback","whenMined","cb","check","web3","eth","getTransaction","err","tx","blockNumber","setTimeout","getTransactionReceipt","receipt","console","log","gas","gasUsed"],"mappings":"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","file":"/imports/lib/helpers/helperFunctions.js.map","sourcesContent":["/**\nHelper functions\n\n@module Helpers\n**/\n\n/**\nThe Helpers class containing helper functions\n\n@class Helpers\n@constructor\n**/\n\nHelpers = {};\n\n\n/**\nReruns functions reactively, based on an interval. Use it like so:\n\n    Helpers.rerun['10s'].tick();\n\n@method (rerun)\n**/\n\nHelpers.rerun = {\n    '10s': new ReactiveTimer(10)\n};\n\n\n/**\nClear localStorage\n\n@method (getLocalStorageSize)\n**/\n\nHelpers.getLocalStorageSize = function(){\n\n    var size = 0;\n    if(localStorage) {\n        _.each(Object.keys(localStorage), function(key){\n            size += localStorage[key].length * 2 / 1024 / 1024;\n        });\n    }\n\n    return size;\n};\n\n\n\n/**\nReactive wrapper for the moment package.\n\n@method (moment)\n@param {String} time    a date object passed to moment function.\n@return {Object} the moment js package\n**/\n\nHelpers.moment = function(time){\n\n    // react to language changes as well\n    TAPi18n.getLanguage();\n\n    if(_.isFinite(time) && moment.unix(time).isValid())\n        return moment.unix(time);\n    else\n        return moment(time);\n\n};\n\n\n/**\nFormats a timestamp to any format given.\n\n    Helpers.formatTime(myTime, \"YYYY-MM-DD\")\n\n@method (formatTime)\n@param {String} time         The timstamp, can be string or unix format\n@param {String} format       the format string, can also be \"iso\", to format to ISO string, or \"fromnow\"\n@return {String} The formated time\n**/\n\nHelpers.formatTime = function(time, format) { //parameters\n    \n    // make sure not existing values are not Spacebars.kw\n    if(format instanceof Spacebars.kw)\n        format = null;\n\n    if(time) {\n\n        if(_.isString(format) && !_.isEmpty(format)) {\n\n            if(format.toLowerCase() === 'iso')\n                time = Helpers.moment(time).toISOString();\n            else if(format.toLowerCase() === 'fromnow') {\n                // make reactive updating\n                Helpers.rerun['10s'].tick();\n                time = Helpers.moment(time).fromNow();\n            } else\n                time = Helpers.moment(time).format(format);\n        }\n\n        return time;\n\n    } else\n        return '';\n};\n\n/**\nRefreshes the status of the currently searched name\n**/\nHelpers.refreshStatus = function refreshStatus() {\n  const name = Session.get('searched');\n  Session.set('searched', '');\n  Session.set('searched', name);\n}\n\n/**\nWaits for a tx to get mined into a block and\nreturns if the tx was successful or not.\n**/\nHelpers.checkTxSuccess = function checkTxSuccess(txid, callback) {\n  function whenMined(txid, cb) {\n    function check() {\n      web3.eth.getTransaction(txid, (err, tx) => {\n        if (err) {\n          return cb(err)\n        }\n        if (tx.blockNumber) {\n          cb(null, tx)\n        } else {\n          setTimeout(check, 500)\n        }\n      })\n    }\n    check();\n  }\n  \n  whenMined(txid, (err, tx) => {\n    if (err) {\n      return callback(err)\n    }\n    web3.eth.getTransactionReceipt(txid, (err, receipt) => {\n      console.log('Gas: ' + tx.gas + ' Gas used: ' + receipt.gasUsed)\n      if (receipt.gasUsed < tx.gas) {\n        callback(null, true)\n      } else {\n        callback(null, false)\n      }\n    })\n  })\n}\n\nexport default Helpers;"]},"hash":"23cab05318c56b00cb744e0e4709adf6b5ec9f8a"}
